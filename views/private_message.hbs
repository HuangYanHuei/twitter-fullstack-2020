<section id="ys-FE-users-private-message">
  <div class="flex-message-page">
    <!--左側導覽列-->
    <section class="left-region-sidebar">
      {{> home-tabs-middleware-ByYS route='private-message'}}
    </section>

    <div class="d-flex">
      <!--使用者清單 開始-->
      <div class="public-message-user">
        <ul class="ul-user-online" id="allUserList">
          <!--每一個使用者 開始-->


        </ul>
      </div>


      <!--聊天室 開始-->
      <div class="public-message">
        <div class="public-message-title">
          <span class="title-span">私人訊息</span>
        </div>
        <div class="public-message-middle">
          <ul class="ul-public-message" id="public-message">
            <li class="li-left-message" style="flex: 1;"></li>
            {{!-- 聊天室內容<li></li>>，一開始為空 --}}
          </ul>
        </div>
        <!--聊天輸入框 開始-->
        <form id="public-message-form" action="">
          <div class="public-message-footer">
            <input id="messageInput" type="text" placeholder="請輸入訊息 ..." maxlength="160" class="public-message-input">
            <button class="send-btn" type="button">
              <img src="/images/submit.png" alt="">
            </button>
          </div>
        </form>
      </div>
    </div>

    <!--socketIo script 開始-->
    <script>
      //  ---- 建立連線
      const PMsocket = io('/private_message')

      // 基本資訊
      const loginUserId = Number('{{loginUser.id}}')
      let targetUserId = Number('{{PmTargetUserId}}')
      let tempRoom = ''
      PMsocket.auth = { userId: '{{loginUser.id}}' }
      PMsocket.emit('updatePmList', targetUserId)

      // 抓取必要的 DOM
      const allUserListDOM = document.getElementById('allUserList')
      const scrollbarRegion = document.querySelector('.public-message-middle')
      const PMessageTitle = document.querySelector('.public-message-title')
      const messagesDOM = document.getElementById('public-message')
      const form = document.getElementById('public-message-form')
      const input = document.getElementById('messageInput')

      // ---- ---- ---- 更新私息人員名單 ---- ---- ----
      PMsocket.on('updatePmList', (PmDataArray, targetUserData) => {
        const AllPmMessages = PmDataArray
        // 整理並排序有傳訊息給您的人員名單，未讀在前
        const usersList = PmDataArray
          .map((PM) => {
            if (PM.receiverId === loginUserId) { return { ...PM.sender, unread: PM.unread } }
            else { return PM.receiver }
          }).sort((a, b) => {
            if (a.unread && !b.unread) {
              return -1
            } else if (!a.unread && b.unread) {
              return 1
            } else {
              return b.createdAt - a.createdAt
            }
          })
        // 將想要 PM 的對象加到人員名單之中
        if (targetUserData) usersList.push(targetUserData)
        // 使用者列表 過濾重複的人名 by id
        const set = new Set()
        const deduplicatedUsersList = []
        usersList.forEach((user) => {
          if (!set.has(user.id)) {
            set.add(user.id)
            deduplicatedUsersList.push(user)
          }
        })
        //  userList 顯示邏輯 --- 
        let rawHTML =
          `
          <li class="li-user-online" style="display:flex">
            <span class="user-title-span">訊息</span>
            <button class="btn btn-outline-second btn-readPM" onclick="readAllPrivateMessage()"
            style="margin: 1.5rem 1.5rem 1.5rem auto;padding: 0.25rem;">
              全部已讀
            </button>
          </li>

          `
        deduplicatedUsersList.forEach((user) => {
          rawHTML +=
            `
          <li class='li-user-online userCard' userName="${user.name}" userId="${user.id}">
            <img src="${user.avatar}"
              class="tweet-user-avatar" style="width:50px;height:50px;display:inline-block;border-radius: 50%;" alt="Picture">
            <span class="li-name" href="/users/${user.id}/tweets">${user.name}</span>
            <span class="li-account" href="/users/${user.id}/tweets">@${user.account}</span>
            
            ${user.unread === 1 ? '<div class="nav-circle-pm nav-circle-count-pm">  </div>' : ''}
          </li>
          `
        })
        allUserListDOM.innerHTML = rawHTML

        // addListener 點擊使用者， 創建私人連線
        allUserListDOM.addEventListener('click', (event) => {
          const targetUserCard = event.target.closest('.li-user-online')
          targetUserId = Number(targetUserCard.attributes.userId.value)
          const targetUserName = targetUserCard.attributes.userName.value
          PMessageTitle.children[0].innerText = targetUserName
          targetUserCard.querySelector('.nav-circle-pm')?.remove('nav-circle-count-pm')

          CreatePrivacyRoom(tempRoom)

          // 呼叫最外層的 Socket ，確認左邊導覽列
          socket.emit('checkIfUnreadPrivateMessage')
        })

        // 定義正在與之聊天的使用者
        let TalkingUserNow
        if (targetUserId) {
          TalkingUserNow = allUserListDOM.querySelector(`[userId='${targetUserId}']`)
        } else {
          TalkingUserNow = allUserListDOM.children[1]
        }
        TalkingUserNow.click()
      })

      // 點擊私訊目標使用者 三步緊
      // ---step1 創建新房間並離開舊房間
      function CreatePrivacyRoom (tempRoom) {
        clearPmCanvasAndShowWait()
        const oldRoom = tempRoom
        PMsocket.emit('join room', { oldRoom, targetUserId })
      }
      // ---step2 房間創建成功，呼叫聊天視窗更新
      PMsocket.on('createRoomSuccessful', newRoom => {
        tempRoom = newRoom
        PMsocket.emit('updateChatBox', targetUserId)
      })
      // ---step3 後端回傳私訊的歷史 log，更新聊天視窗
      PMsocket.on('updateChatBox', (receivedPmMessages) => {
        clearPmCanvasAndShow()
        const msgArray = MappingPmToMessageArray(receivedPmMessages)
        msgArray.forEach((msgObj) => { showMessageOnChatBox(msgObj) })
      })


      function MappingPmToMessageArray (AllPmMessages) {
        const filteredPM = AllPmMessages.filter((pm) => {
          const senderId = pm.senderId
          const receiverId = pm.receiverId
          return (senderId === targetUserId || senderId === loginUserId) && (receiverId === targetUserId || receiverId === loginUserId)
        })
        return filteredPM.map((pm) => { return { ...pm.sender, message: pm.message } })
      }

      function readAllPrivateMessage () {
        PMsocket.emit('readAllPrivateMessage')
        $('#tab-privateMessage').removeClass('main-color-blink')
        $('.userCard').find('.nav-circle-pm').removeClass('nav-circle-count-pm')
      }

      function clearPmCanvasAndShow () {
        messagesDOM.innerHTML = `<li class="li-left-message" style="flex: 1;"></li>`
      }

      function clearPmCanvasAndShowWait () {
        messagesDOM.innerHTML = `<li class="li-left-message" style="flex: 1;flex-direction: column;margin-top: 35vh;"> 讀取中 請等等</li>`
      }

      //  ----聊天室的邏輯區域  input 欄位 
      form.addEventListener('submit', function (e) {
        e.preventDefault()
        if (input.value) {
          PMsocket.emit('private message', { receivedMsg: input.value, targetUserId })
          input.value = ''
        }
      })

      //  ----聊天室的邏輯區域   接收在 私訊 傳來的資料   
      PMsocket.on('private message', function (receivedObj) {
        showMessageOnChatBox(receivedObj)
      })

    </script>
    <!--socketIo script 姞束-->
  </div>
</section>